This is an example exercise in using Python’s standard [SSL
module](https://docs.python.org/3/library/ssl.html) to set up a secure
connection between a client and a server process, using self-signed
certificates and two-way authentication. This kind of thing is useful
for internal organizational use, where authentication is only needed
between machines that you control, not between you and the general
public. So you are free to create your own CA certificate, and install
it for use on these machines.


Certificate Setup
=================

The details of certificate setup assume you are using
the [OpenSSL](https://www.openssl.org/) command-line tools.

To use these programs, first you need to set up your own CA
configuration, for example in a subdirectory of this source
directory named `auth`:

    mkdir auth

Within the `auth` directory, create a minimal CA configuration file,
for example named `test-ca.conf`, containing something like

    [ca]
    # name of actual CA section (arbitrary)
    default_ca = CA_default

    [CA_default]
    dir = auth/test-ca
    database = $dir/index.txt
    new_certs_dir = $dir/new_certs
    serial = $dir/serial
    # default_days = validity interval if “-days” option not specified in command
    default_days = 30
    # default message-digest algorithm
    default_md = default
    # name of policy section to use
    policy = policy_match

    [policy_match]
    # need following to ensure CN ends up in “Subject:” line for cert
    commonName = supplied
    # try adding following as well
    countryName = optional
    stateOrProvinceName = optional
    localityName = optional
    organizationName = optional
    organizationalUnitName = optional
    # according to <https://ldapwiki.com/wiki/Distinguished%20Names>,
    # e-mail address doesn’t belong in a DN. It should be in something
    # like a GeneralName attribute.
    emailAddress = optional

Create additional files and subdirectories as referenced in the above
configuration:

    mkdir auth/test-ca auth/test-ca/new_certs
    touch auth/test-ca/index.txt

including a starting serial number (seems to require at least 4 digits):

    echo 1001 >auth/test-ca/serial

Create your self-signed CA certificate, with some suitable identification
information and validity interval:

    openssl req -new -x509 \
         -subj "/C=NZ/ST=Waikato/L=Hamilton/O=MegaCorp Inc/OU=Trust Me/CN=Trust Me" \
         -newkey rsa:2048 -nodes -days 365 \
         -keyout auth/test-ca/test-ca.key -out auth/test-ca/test-ca.cert

Create requests for separate client-side and server-side certificates,
so each end can authenticate to the other:

    openssl req -new \
         -subj "/C=NZ/ST=Waikato/L=Hamilton/O=MegaCorp Inc/OU=Client/CN=Client" \
         -newkey rsa:2048 -nodes \
         -keyout auth/client.key -out auth/client.req

    openssl req -new \
         -subj "/C=NZ/ST=Waikato/L=Hamilton/O=MegaCorp Inc/OU=Server/CN=Server" \
         -newkey rsa:2048 -nodes \
         -keyout auth/server.key -out auth/server.req

Sign the certificate requests with your CA certificate to turn them into
actual certificates:

    openssl ca -config auth/test-ca.conf \
        -cert auth/test-ca/test-ca.cert -keyfile auth/test-ca/test-ca.key \
        -in auth/client.req -days 30 -out auth/client.crt

    openssl ca -config auth/test-ca.conf \
        -cert auth/test-ca/test-ca.cert -keyfile auth/test-ca/test-ca.key \
        -in auth/server.req -days 30 -out auth/server.crt

A certificate can contain all kinds of identifying information, which
cannot be tampered with once the certificate has been signed. For
example, the server can use the “subject” information as the
identifying username, to look up which services the client is allowed
to access. Such privileges could be encoded into the certificate
itself, but then changing such information requires revoking existing
certificates and issuing new ones. Of course, the server can have
access to a list of the CA-unique serial numbers of revoked
certificates, and use that to reject a certificate which has otherwise
passed verification.


Running The Programs
====================

Finally, you are ready to actually run the server and client scripts.
The example protocol is absolutely trivial, and just involves the
client sending an integer to the server, which adds 1 to it and sends
the result back.

For extra fun, try the two ends in different terminal sessions, so you
can see both sets of output at once. Both of them need the CA cert
(though not its private key!); in addition, the server needs the
server-side cert and private key, while the client similarly takes the
client-side ones. All of these file names are passed as command
arguments. First, start the server (assuming the file names are as the
examples above):

    ./server_try auth/test-ca/test-ca.cert auth/server.crt auth/server.key

Then, the client:

    ./client_try auth/test-ca/test-ca.cert auth/client.crt auth/client.key

and watch the messages.

After the client terminates, the server keeps running, so that it can accept
more client connections. To stop it, type CTRL/C.


Other Things To Try
===================

The scripts as written also allow you to deliberately violate the
protocol in various ways, to see how the other end will react. For
example, you can omit passing a certificate and key file to either
end, though you still have to pass the CA certificate. If you do this,
you should see the other end reject the connection, because the TLS
verification mode is set to require a certificate at both ends.

Also, the `client_try` script has “`--noread`” and “`--nowrite`” options,
where it will send requests without bothering to receive replies, or
alternatively not bother to send requests at all, and just sit listening
for replies which will never come. The server side should timeout and
abort the connection in these situations.

The `--noread` scenario is interesting, because on my machine the client
can get up to about 600,000 requests sent before the buffers in the
Linux kernel network stack get filled with unreceived server replies, and
further sending is blocked.

For fun, try creating a second CA, and use it to sign the same certificate
requests to create new, alternative certificates. Pass the alternative
CA and certificate (keeping the same key file) to one end, and see how
the other end reacts--it should fail on the authentication handshake,
because it doesn’t recognize the other CA.

Of course, passing the same alternative CA and certs to both ends should
work fine.

Lawrence D'Oliveiro <ldo@geek-central.gen.nz>
2023 January 1
